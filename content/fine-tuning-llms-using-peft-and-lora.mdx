---
title: "Guide to fine-tuning LLMs using PEFT and LoRa techniques"
slug: fine-tuning-llms-using-peft-and-lora
publishedAt: "2023-09-01"
createdAt: "2023-07-10"
updatedAt: "2023-09-01"
summary: "Using Low-rank adaptation (LoRA) and other PEFT techniques can help you train LLMs and other models faster and in a much cheaper way."
authors:
  - name: "Pranav Patel"
category: "Large Language Models"
image: "https://uploads-ssl.webflow.com/640f56f76d313bbe39631bfd/64ac7af09311957ab6dbecc1_Peft%20finetuning.png"
---

<div class="rich-text w-richtext"><p>Large Language Models (LLMs) like GPT are getting only larger in size. Even open-source models like <a href="https://huggingface.co/mosaicml/mpt-30b">MPT</a> and <a href="https://huggingface.co/tiiuae/falcon-40b">Falcon</a> have reached 30 and 40 billion parameters respectively. With size, the capabilities and complexities of these models have also increased. But this increased complexity and model size can also create challenges. Training larger models requires more extensive data sets, and as the model grows, more parameters must be tuned. This can be very compute-heavy and as a result costly too. This is where fine-tuning comes in. Fine-tuning is a technique that allows for the re-purposing of pre-trained models and can help reduce the complexity of building larger models. </p><p>In this blog, we will discuss advanced fine-tuning techniques like PEFT (Parameter Efficient Fine-Tuning) and see how they can save you a ton of time and money on training massive LLMs.</p><h2 id="what-is-fine-tuning">What is Fine-tuning?</h2><p>Fine-tuning is the process of taking a model that is already trained on some task and then tweaking it to perform a similar task. It is often used when a new dataset or task requires the model to have some modifications, or when the model is not performing well on a specific task.</p><p>For example, a model trained to generate stories can be fine-tuned to generate poems. This is possible because the model has already learned how to generate casual language and write stories, this <em>skill</em> can also be used to generate poems if the model is tweaked properly.</p><h3 id="how-does-fine-tuning-work">How does Fine-tuning work?</h3><p>As mentioned, fine-tuning is tweaking an already-trained model for some other task. The way this works is by taking the weights of the original model and adjusting them to fit a new task.</p><p>Models when trained learn to do some specific task, for example, GPT-3 has been trained on a massive dataset and as a result, it has learned to generate stories, poems, songs, letters, and a lot of other things. One can take this ability of GPT-3 and fine-tune it on a specific task like generating answers to customer queries in a specific manner.</p><p>There are different ways and techniques to fine-tune a model, the most popular being <em>transfer learning</em>. Transfer learning comes out of the computer vision world, it is the process of freezing the weights of the initial layers of a network and only updating the weights of the later layers. This is because the lower layers, the layers closer to the input, are responsible for learning the general features of the training dataset. And the upper layers, closer to the output, learn more specific information which is directly tied to generating the correct output.</p><p>Here is a quick visualization of how fine-tuning works:</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1438pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796a220d3feb89bedcef_gksjp_6BS_dpO8KdfKa51eQ_BNcKLnmQlNcZRdg5MHOqfJoj7bMoUf3rJwUpk1fZh64R0zSo5jl1nMRzfeBQuiZ63R4rO8PsOvEWLNR3QrQCBdC8qvtRk6C0K5_0xd6zGc_zoy96cgqHz5_kSa-jQfw.gif"/></div></figure><p><em>Alammar, J (2018).  </em><a href="https://jalammar.github.io/illustrated-transformer/"><em>The Illustrated Transformer</em></a> <em>[Blog post].</em></p><h3 id="why-use-fine-tuning">Why use Fine-Tuning?</h3><p>As the model size increases, it becomes more costly and time-consuming to train it. And with more size it requires more training data, otherwise, models usually overfit and generate poor results in a production environment. Fine-tuning allows us to not run into these issues by efficiently using a pre-trained model for our purposes. Here are some reasons why you should consider fine tuning instead of training a model from scratch:</p><h4 id="larger-models-generalize-to-downstream-tasks-well">Larger models generalize to downstream tasks well</h4><p>We all know how large models like GPT-3 and GPT-4 can perform really well on complicated tasks. This is because they have very sophisticated architectures and are trained on massive datasets, this helps them generalize on a lot of tasks really well. These models understand the underlying properties of language and that helps them learn any new tasks with minimal effort like prompt engineering.</p><p>But if we want to use these models for some very specific tasks, like building a legal contract generator, you should probably fine-tune the model instead of using prompt engineering. This is because a model performing well in a very general task like language generation will perform well in a downstream task like generating legal contracts.</p><h4 id="cheaper-than-training-a-whole-model">Cheaper than training a whole model</h4><p>As mentioned before, these large models can be very expensive to train from scratch. Also very time-consuming. It is always cheaper to train an already-trained model. This also allows you to leverage what is already out there instead of doing everything yourself. Most of the time good datasets can be very hard and time-consuming to build. Open-source models like <a href="https://huggingface.co/mosaicml/mpt-30b">MPT</a> and <a href="https://ai.facebook.com/blog/large-language-model-llama-meta-ai/">LLaMA</a> have already been trained and made sure that they work well by some of the best researchers out there. It is very easy to load and train them in a cloud infrastructure.</p><h4 id="good-for-online-training">Good for online training</h4><p>One of the biggest challenges in AI is to keep the model up to date with the latest data. Models when deployed in production can start degrading in performance if not updated regularly. For example, if you deploy an AI model to predict customer behavior in a store, it might stop performing well once the store is restocked with products with different prices or if they introduce new products in the store. This is a classic example of how changes in data can drastically change the performance of a model. </p><p>Fine-tuning can help you to keep updating the model with the latest data without having to re-train the whole model. This makes it possible to deploy models in production without much effort and cost. This is called online learning or online training and is absolutely necessary for any model in production.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1175pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796a5f93c078881443f3_xoH3raA0kMV9Fg-sVtG84G5NI_irw72IksNhONqjeZAdDnkaME7av4Jiopt9zHumsz2bwosamV5Yzp59jsFZliX5K7RCoomps5tsED3FcZPpiiQ3RImJXRUfq3ycN54flyjmxJ5LunNLbrYFV7SiDos.png"/></div></figure><h2 id="what-is-peft">What is PEFT?</h2><p>PEFT, Parameter Efficient Fine-Tuning, is a set of techniques or methods to fine-tune a large model in the most compute and time-efficient way possible, without losing any performance which you might see from full fine-tuning. This is done because with models growing bigger and bigger like <a href="https://huggingface.co/docs/transformers/model_doc/bloom">BLOOM</a> which has a whopping <strong>176 billion </strong>parameters, it is almost impossible to finetune them without spending tens of thousands of dollars. But it is sometimes almost necessary to use such big models for better performance. This is where PEFT comes in. It helps you solve the problems faced during such big models.</p><p>Here are some PEFT techniques:</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1322pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796b64197e69fc87f670_iWe274ACYUm0_Q-aPmdQPWUSWZR4YnNs2gP7xxX2sCZh7TXPL5WWfOu4pEkJGBkNridVRNFMnkHlc3NjE9M-5SMlv9pksU1LZ_G7Jjb7OzPXNeqKpURkaGfWa5uyWL48sle16BUmXsGlTHOk8ui4xIA.png"/></div></figure><h3 id="why-peft">Why PEFT?</h3><p>As mentioned above, it has become a necessity to fine-tune and use bigger models when it comes to production-grade applications. PEFT techniques allow you to fine-tune the models efficiently and save money and time as a result. This is done by fine-tuning only the most important and relevant parameters in the neural network. The techniques introduce new parameters in the network or freeze the whole model except for some parts to make it easier to train the model.</p><h2 id="transfer-learning">Transfer Learning</h2><p>Transfer learning is when we take some of the learned parameters of a model and use them for some other task. This sounds similar to fine-tuning but is different. In finetuning, we re-adjust all the parameters of the model or <em>freeze</em> some of the weights and adjust the rest of the parameters. But in fine-tuning, we use some of the learned parameters from a model and use them in other networks. This gives us more flexibility in terms of what we can do. For example, we cannot change the architecture of the model when fine-tuning, this limits us in many ways. But when using transfer learning, we use only a part of the trained model, which we can then attach to any other model with any architecture.</p><h3 id="how-transfer-learning-works">How Transfer Learning Works</h3><p>Transfer learning has been a common practice in the computer vision world for a very long time now. This is because of the nature of the visual models and how they learn. In CNN models, the early layers extract more general features like edges and curves, whereas the later layers extract more complicated features like whole eyes and faces. This is because the receptive field of CNNs grows as they are stacked on top of each other.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:242pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796a1def5997ce0baa32_U46S6iJQLnVqHJ1LGxDtJRDMWHKYb37vDR9pYrfja7281G78AxIIYeiFgXDvBkDKDAYD_wUeUKfgktRaep1HHRE1_hfXshnW0gqt8_KJQa65h3mnu5W_53FUzp_zdPkrES_9KoZfQKAkmYmP30cbw_E.png"/></div></figure><p>Let’s say for example you are trying to train a neural network to classify if a vehicle in front of you is a car or a motorbike. This is a very basic task. But let’s say you have very limited data and you don’t want to train your model too much. Here is what a basic CNN network looks like.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1452pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796a1def5997ce0baa43_jab3buYuSz0FRlKFQuxdtoFlqCDAW_Nf31qJA5Taqo42KJqoWLezsdTsA8W1klbWAAvNZ1RKnHUtLX261SKOBqQB9UDZpSOQCB1ihC4qSRZyNoIIC7Psjel7XbaoFgKanUy9SkzjmgB3rUzhrATPgSk.png"/></div></figure><p>There are 2 major parts of the network here, the CNN head and the later fully connected layers. As mentioned, CNN layers extract <em>representations</em> of the data which then are used by the fully connected network to classify the image. Here we can use any other CNN network trained on a similar classification problem and use that as the CNN head for this new problem.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1430pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796aee80430969e1b55c_bGcQDyySuDDZfgUx_IU-dsNXrx0gtRVHQXM7zLhPiiEvSdnu10727d4iV9Tg41MMDAEY0WKpM2PT5Z3iQQ73iFxBHU9VFWFwrf1Iff2Y6rSF0_AW7cFgXjpw2G2rw8h2Y9hvuRQlxhdHZIGZwTtvvko.png"/></div></figure><p>Here as you can see, we are using transfer learning by using the weights of a network pretrained to classify the car type. We are only <em>freezing</em> the first two layers of the CNN network, and leaving the latter two free to be updated during the training process. This makes sure that the CNN head of the model learns new features from the images which might be necessary for the new task we are training the model for.</p><p>Transfer learning is also often seen in NLP tasks with LLMs where people use the encoder part of the transformer network from a pretrained model like T5 and train the later layers.</p><h2 id="adapters">Adapters</h2><p>Adapters were one of the first parameter-efficient fine-tuning techniques released. In the <a href="https://arxiv.org/abs/1902.00751">paper</a>, they showed that you can add more layers to the pre-existing transformer architecture and only finetune them instead of the whole model. They showed that this technique resulted in similar performance when compared to complete fine-tuning.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:778pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796b2cf93ff7ca7a4c38_NYcHjBoLPNr0WP0Le-F7x_7sJ8PXpyQRRQ0gM-0Qi7NTL-9PY3W-E_YH7QjrjAMdjG6t9LowvUg2kSaPcIv_G2MLJNakeMu8idZCwix1pPXSj-jXDQyaF_iYXOLHSEuUHDG17ZnBvfrDIwUuLmudI20.png"/></div></figure><p>On the left, there is the modified transformer architecture with added adapter layers. You can see adapter layers are added after the attention stack and the feed-forward stack. And on the right, you can see the architecture of the adapter layer itself. The adapter layer comprises a bottleneck architecture, it takes the input and narrows it down to a smaller dimension representation and then passes it through a non-linear activation function, and then scales it back up to the dimension of the input. This makes sure that the next layer in the transformer stack will be able to receive the generated output from the adapter layer.</p><p>In the paper, the authors show that this method of fine-tuning is comparable to complete fine-tuning while consuming much less compute resources and training time. They were able to attain 0.4% of full fine-tuning on the GLUE benchmark while adding 3.6% of the parameters.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796bb31d4755e5b9f245_6Pf3OFK7AznckqlTNxGUyXDxbjAP-ffOHAkI-C3XjwXuQAlZ-Z16akAAd4AVHLy7ha2Uu86_-sx4dJFjPa4X04SXBRyZM13JiCZS2Yx7h1M_pr6lO_FXlO7Tvluv6EoD0u_lShCh_K1fvj9Jk2twwU4.png"/></div></figure><h2 id="lora-low-rank-adaptation">LoRA - Low-Rank Adaptation</h2><p>LoRA is a similar strategy to Adapter layers but it aims to further reduce the number of trainable parameters. It takes a more mathematically rigorous approach. LoRA works by modifying how the updatable parameters are trained and updated in the neural network.</p><p>Let’s explain mathematically, you can skip to the next paragraph if you are not interested. We know that the weights matrices of a pretrained neural network are full rank, meaning each weight is unique and can't be made by combining other weights. But in <a href="https://arxiv.org/abs/2012.13255">this</a> paper authors showed that when pretrained language models are adjusted to a new task the weights have a lower “intrinsic dimension”. Meaning, that the weights can be represented in a smaller matrix, or that it has a lower rank. This in turn means that during backpropagation, the weight update matrix has a lower rank, as most of the necessary information has already been captured by the pre-training process and only task-specific adjustments are made during fine-tuning.</p><p>A much simpler explanation is that during finetuning only a very few weights are updated a lot as most of the learning is done during the pretraining phase of the neural network. LoRA uses this information to reduce the number of trainable parameters.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1219pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796b52955d6d3a8e667c_mtT--qmnIZxHjHPCETS9PnUPkjyC_tQgV5suVwlyK4cRVckfUPo6zt2KXE2BGcO1rqQkfyhX5tR-jkJPwv7k8Km279JpDEopXqCNTqF20AmZhkxn2AIYTBkgfyyiWJ214hGAKtAuJ2EAOkgt8qJbCPM.png"/></div></figure><p>The image above gives a visual representation of what LoRA is doing. The Δ<em>W<sub>AxB </sub></em>is the weight updation matrix, these are the changes needed to be applied to the neural network in order for it to learn a new task. This matrix can be broken down into two matrices and then we can only train them and then use them to get back our weight updation matrix. As you can see in the image, the matrix is broken down into matrices with columns and rows <em>r</em>, it can be understood as the <strong>rank</strong> of the weight updation matrix if it was actually trained. The bigger the rank, the more parameters will be updated during training.</p><h3 id="efficiency-of-lora">Efficiency of LoRA</h3><p>Authors in the paper show that LoRA can <strong>outperform</strong> full finetuning <strong>with only 2% of total trainable parameters</strong>. </p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:994pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796b33bf8099615d1cc4_RjrvdIVZHbUoDY64Rs67dN5VUb1eaXU1rb1AXuxh719N5v_o2KA_aDchDadXjzOstc-mNqeUfT1bXCvcq2Uzq5XxgArhUiXVKNizRlEQMqCoL176aV-RLeKaKRCcm-hrIyGsw1HNIN1y1joFMduSctw.png"/></div></figure><p>As for the number of parameters it trains, we can largely control that using the rank <em>r</em> parameter. For example, let’s say the weight updation matrix has 100,000 parameters, <em>A</em> being 200 and <em>B</em> being 500. The weight updation matrix can be decomposed into smaller matrixes of lower dimensions, <em>A</em> being <em>200 x 3</em> and <em>B</em> being <em>3 x 500</em>. This gives us <em>200 x 3 + 3 x 500 = </em><strong><em>2100</em></strong> trainable parameters only, which is only <strong>2.1%</strong> of the total number of parameters. This can be further reduced as we can decide to only apply LoRA to specific layers only.</p><p>As the number of parameters trained and applied are MUCH smaller than the actual model, the files can be as small as <strong>8MB</strong>. This makes loading, applying, and transferring the learned models much easier and faster.</p><p>You can read the <a href="https://arxiv.org/abs/2106.09685">LoRA paper</a> if you want to learn more and do a deeper dive into the topic.</p><h3 id="lora-in-stable-diffusion">LoRA in Stable Diffusion</h3><p>One of the most interesting use cases of LoRA can be shown in image generation applications. Images have an inherent <em>style</em> that can be visually seen. Instead of training massive models to get specific styles of images out of models, users can now only train LoRA weights and use them with techniques like <a href="https://dreambooth.github.io/">Dreambooth</a> to achieve really good quality images with a lot of customizability.</p><p>LoRA weights can also be combined with other LoRA weights and be used in a weighted combination to generate images that carry multiple styles. You can find a ton of LoRA adapters online and load them into your models on <a href="https://civitai.com/">CivitAI</a>.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1600pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796cb0b88a3f25a5aba9_2JwaTCH1vvT8nnzzzQ8pSTQi-bJSgHBfZORoGjOHs6QzmY8dMECiTpHz9mbVBNJuCEvnSeOEGNI1zBJI5XZfZ1tJYI4mpJ1hQykIkbqg_Y_fgfKU1QBS5E_Q7AFnegtmcoLQLdcxmqKczk4zGg17-TE.png"/></div></figure><h2 id="ia3-infused-adapter-by-inhibiting-and-amplifying-inner-activations">IA3 - Infused Adapter by Inhibiting and Amplifying Inner Activations</h2><p><a href="https://arxiv.org/abs/2205.05638">IA3</a> is an adapter-based technique that is somewhat similar to LoRA. The goal of the authors was to replicate the advantages of ICL (in context learning or Few-Shot prompting) without the issues that come with it. ICL can get messy in terms of cost and inference as it requires prompting the model with examples. Longer length prompts require more time and computation to process. But ICL is perhaps the easiest way to get started working with models.</p><p>IA3 works by introducing <strong>rescaling vectors</strong> that target the activations of the model. A total of 3 vectors are introduced, <em>l<sub>v</sub>, i<sub>k, </sub></em>and <em>l<sub>ff</sub>. </em>These vectors target the <em>value, keys</em> in the attention layer, and the <em>non-linear</em> layer in the dense layers. These vectors are multiplied elementwise to the default values in the model. Once injected, these parameters are then learned during the training process, while the rest of the model remains frozen. These learned vectors essentially rescale or optimize the targeted pretrained model weights for the task at hand.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:963px"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64f258167f01443dc5873fd7_b1JmzItn0cZq5XLABg3j4GI3m45obrl0DtDIs1e3c1K5BsQmrZwHUxb1-G9W2GK65WEdXObzu-2NZ0TSzZWyaahY4Brhogg8mnkDCcKBXrjMEiobDqdW1PNZ3baXGXQcJ2m2H9QuytN5sE4D9fmiPxY.png"/></div></figure><p>So far this seems like a basic adapter type PEFT method. But that’s not all. The authors also use 3 loss terms to enhance the learning process. The 3 losses are <em>L<sub>LM</sub>, L<sub>UL,</sub> </em>and<em> L<sub>LN</sub></em>. <em>L<sub>LM</sub></em> is the standard cross-entropy loss, which increases the likelihood of generating the correct response. Then there is <em>L<sub>UL</sub></em> which is <em>Unlikelihood Loss</em>. This loss term reduces the probability of incorrect outputs using Rank Classification. Finally, we have <em>L<sub>LN</sub></em>, which is a length-normalized loss that applies a softmax cross-entropy loss to length-normalized log probabilities of all output choices. Multiple losses are used here to ensure faster and better learning of the model. Because we are trying learn using few-shot examples, these losses are necessary.</p><p>Now let’s talk about two very important concepts in IA3. Rank Classification and Length Normalization.</p><p>In Rank Classification a model is asked to rank a set of responses by their correctness. This is done by calculating the probability scores for the potential responses. The L<sub>UL </sub>is then used to reduce the probability of the wrong responses and as a result, increase the probability of the correct response. But with Rank classification, we face a critical problem, which is that the responses with fewer tokens will rank higher, because of how probability works. A smaller amount of generated tokens ensures a higher probability as the probability of every generated token is &lt; 1. To fix this, the authors propose dividing the score of the response by the number of tokens in the response. Doing this will normalize the scores. One very important thing to note here is that normalization is done over log probabilities, not raw probabilities. Log probabilities are negative and between zero to one.</p><h3 id="efficiency-of-ia3">Efficiency of IA3</h3><p>IA3 just like LoRA reduces the number of trainable parameters. But instead of using low-rank matrices, IA3 uses rescaling vectors. This reduces the trainable parameters to about 0.01%, compared to LoRA's &gt; 0.1%, for the T0 model trained in the paper. The frozen state of the LLM also provides us with the option of having multiple adapters for multiple use cases. Also, because the authors used element-wise multiplication, it is super easy to merge the adapter to the LLM weights because of the commutative property of multiplication.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1247px"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64f2581684d2e29d3f357ee7_nh7Jp_Bv3DSHLC3rjBFirxHpQ04gjvM-T1zn7OfHpRcwtcNf9lyampebUIWUILzJ5tegpu6-8ySzmX2nohM5ODOH_ozBNMGQNr3EbV-UpVR0jbmKe_wsFehjKJqKDqJ6XaNJuAGwVmT7zNVsOMPbrgA.png"/></div></figure><p>The above figure shows that IA3 performs better than LoRA and barely affects the FLOPs. This makes IA3 a highly efficient and desirable technique. Also because IA3 is an additive adapter technique, just like LoRA we can target specific parts of the model and decide where to introduce the rescaling vectors. This helps us reduce the training time and even more.</p><h2 id="p-tuning">P-Tuning</h2><p>The P-tuning method aims to optimize the representation of the prompt which is passed to the model. In the <a href="https://arxiv.org/abs/2103.10385">P-Tuning paper</a>, the authors emphasize how prompt engineering is a very strong technique when working with large language models. The p-Tuning method builds up on top of prompt engineering and tries to further improve the effectiveness of a good prompt.</p><p>P-Tuning works by creating a small <em>encoder network</em> for your prompt that creates a <em>soft prompt</em> for your passed prompt. To tune your LLM using P-tuning, you are supposed to create a <em>prompt template</em> that represents your prompt. And a context <em>x</em> which is used in the template to get label <em>y</em>. This is the approach mentioned in the paper. The tokens used for the prompt template are trainable and learnable parameters, these are called <em>pseudo tokens</em>. We also add a prompt encoder which then helps us update pseudo tokens to the specific task at hand. The prompt encoder is usually a <em>bi-LSTM</em> network that learns the optimal representation of the prompt for the model and then passes the representation to it. The LSTM network is attached to the original model. Only the encoder network and the pseudo tokens are trained here, the weights of the original network remain unaffected. Once the training is done, the LSTM head is discarded as we have the <em>h<sub>i</sub> </em>which can be used directly.</p><p>In short, the prompt encoder only changes the embeddings of the passed prompt to better represent the task, everything else remains unchanged.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1470pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796b04cddb42676dc685_aM4QCzgu6ql_uqxJuHdVBwnMkbaY2QzJ855KSVzwnk1_BVwpnKXBZHGqo87QZMSK1b3YvLrSdxNrYqIX6HH3n9tLXJ_HsWhxqN15LgT15jB0N2I1p7OdJ2E-1rLeMfhGpSDf2qe9rD4xw__aBwns9xY.png"/></div></figure><h3 id="efficiency-of-p-tuning">Efficiency of P-Tuning</h3><p>In terms of efficiency, P-tuning is just as good as any other method. In the paper, the authors show that P-Tuning was able to perform <strong>better than full fine-tuning</strong> on most of the benchmarks. It can be said that P-Tuning is comparable to the full fine-tuning of large language models.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1455pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796c5ab7e0b32071c2a9_8iTDr8NKlsgmLyo_TIIfUXrfiHR-cnm-8CkCbZRKhO7Otf9pdiOa_3sfkp_OXNGgkuBS54RRAJTqxSXlrwNMQFn4I1VwKxdHzNRjcFHx1O7MWT1OjklldGpZQZwIYvBQBR5dUhCIaOofJ1lm5Hpivvw.png"/></div></figure><p>But there is a core issue when it comes to P-Tuning. P-Tuning is a prompt optimization technique, it optimizes the prompt that is passed to the bigger model. This means that we are still largely based on the large model in terms of capability. If a model has not been trained on sentiment classification optimizing sentiment classification prompts using P-Tuning will not do a lot of good to the model. P-Tuning is an assistive technique. It is always very important to pick a model that can do the required task out of the box “well” with some prompt engineering, and then further optimize it.</p><h2 id="prefix-tuning">Prefix Tuning</h2><p>Prefix tuning can be considered the next version of P-Tuning. The authors of P-Tuning published a paper on <a href="https://arxiv.org/abs/2110.07602">P-Tuning V-2</a> addressing the issues of P-Tuning. In this paper, they implemented the Prefix tuning introduced in <a href="https://arxiv.org/abs/2101.00190">this paper</a>. Prefix tuning and P-Tuning do not have a lot of differences but can still lead to different results. Let’s dive into a deeper explanation.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1153pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796ca90f165006083da8_A_KieXmVWiCxx2HDCfnPhP7Yw67KDpTn6tqFF_8wKNMel0AfOZu3NoNHfvm23O2F8yVbjYl73WH8XLHXvlCn1MoRch5wHMlZmpEKL32wgTf9-JvVRqf8IuzuyknPLe5RWQ57I3tXFGe4dhuLu0z_Ni4.png"/></div></figure><p>In P-Tuning, we added learnable parameters only to the input embeddings but in Prefix Tuning we add them <strong>to all the layers of the network</strong>. This ensures that the model itself learns more about the task it is being finetuned on. We append learnable parameters to the prompt and to every layer activation in the transformer layers. The difference from P-Tuning is that instead of completely modifying the prompt embeddings, we only add very few learnable parameters at the start of the prompt at every layer. Here’s a visual explanation:</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1600pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796c5ab7e0b32071c301_LMgayME_f2cuV5YWWcSeCLRFXyU4y4mE4kbfajfq-OSTH06PnqhYgJscRCji-KLqKk8C25-ZbqR2PN15Ffr1kFT5EVGXIcF3eghgDe8A9GYeLDwXxZNZ-YhrjCYltq_qbOUrh17SmcN1BE5DczTE6KE.png"/></div></figure><p>At every layer in the transformer, we concatenate a soft prompt with the input which has learnable parameters. These learnable parameters are tuned using a very small MLP, only 2 fully connected layers. This is done because in the paper authors note that directly updating these prompt tokens is very sensitive to learning rate and initialization. The soft prompts increase the number of trainable parameters but substantially increase the learning ability of the model too. The MLP or fully connected layers can be dropped later as we only care about the soft prompts, which will be appended to the input sequences during inference and will guide the model.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1128pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796cb31d4755e5b9f326_gxwL6634yC6BJhGonpxUj78cM0Z_hJM-wmxiJuhhsF9PiK1W-g_eLCpalPG3Z9vjAMsbBwyx-mnG_ALUC1qak9i0QRK0hlPeUI5V_15TdHDM6fWCNfOgujr4F6RYxH4g9znSx-DE4UGpKQAr2ItcOFU.png"/></div></figure><h3 id="efficiency-of-prefix-tuning">Efficiency of Prefix Tuning</h3><p>Prefix tuning shows massive gains over P-Tuning. And as the model size increases, these gains increase too. This is perhaps because there are more trainable parameters for larger models. In the chart, you can see the authors compare the performance of P-Tuning, full finetuning, and Prefix tuning. Prefix tuning performs better than or as well as P-tuning in almost all tasks. In many cases, it performs even better than Full fine-tuning!</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1580pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796c1def5997ce0bad2b_HWKJYOvpznNVd06S-B6iw8qRyrCrvv4qUwjTPN7SDhIUDvbFsNS7__2EoLWnWyM7TlwUs98vXnxnfmDORHZ6b4Rdcgyvf6roYNmFfhMZIpVxl2LmHijQgBytA9CDvJJhD-N3uteFL4f0QdXFsrCX1dA.png"/></div></figure><p>One big reason why prefix tuning works really well is that the number of trainable parameters is not limited only to the input sequence. Learnable parameters are added at every layer, making the model much more flexible. Prefix tuning, unlike P-tuning, not only affects the prompt tokens but also the model itself. This allows the model to learn more. But this approach is still largely based on the prompt. It is still suggested to take a model that can perform the task and only then optimize it, as that will lead to much better results. As for the size of parameters, the number of trained parameters increase substantially, from <strong>0.01% to 0.1 to 3% parameters</strong>. But the size of parameters still remains small enough to be transferred and loaded easily and quickly.</p><h2 id="prompt-tuning">Prompt Tuning</h2><p>Prompt tuning was one of the first papers to build upon the idea of finetuning only with soft prompts. The ideas of P-Tuning and Prefix Tuning come from this paper. Prompt tuning is a very simple and easy-to-implement idea. It involves prepending a specific prompt to the input and using virtual tokens or new trainable tokens for that specific prompt. These new virtual tokens can be finetuned during the process to learn a better representation of the prompt. This means that the model is tuned to understand the prompt better. Here is a comparison of prompt tuning with full fine-tuning from the paper:</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1310pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796dcfdba29eb2c9287c_61MouOmSUGteW9qoekJTGOfmat0OhESch4gqkOztM_39O3bmE2GxvQ8OsHPpF06lSSQYY-zPGWhM2w3P6eQoD2OG_Q46WpR0RCAoAq0q0qZisLDvSbSRio-jJKcmO44MelRp1fhxAD9bm_g2tgfjH9k.png"/></div></figure><p>Here you can see that full model tuning requires multiple copies of the model to exist if we want to use the model for multiple tasks. But with Prompt Tuning, you only need to store the learned virtual tokens of the prompt tokens. So for example, if you use a prompt like <em>“Classify this tweet: {tweet}” </em>the goal will be to learn new better embeddings for the prompt. And during inference, only these new embeddings will be used to generate the outputs. This allows the model to tune the prompt to help itself generate better outputs during inference.</p><h3 id="efficiency-of-prompt-tuning">Efficiency of Prompt Tuning</h3><p>The biggest advantage of using prompt tuning is the small size of learned parameters. The files can be in <strong>KBs.</strong> As we can determine the dimension size and number of parameters to use for the new tokens, we can greatly control the number of parameters we are going to learn. In the paper, the authors show how even with a very small number of trainable tokens method performs really well. And the performance only goes up as bigger models are used. You can read the paper <a href="https://arxiv.org/abs/2104.08691">here</a>.</p><figure class="w-richtext-align-center w-richtext-figure-type-image" style="max-width:1165pxpx"><div><img alt="" loading="lazy" src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/64ac796d4542b678f53df34a_T0sHFW8zg2lugHlswaWtCgjGfZ_LQMcSBr8VYCOAfwwWFzwWtVXtY13ytAUPV_8tkYklYbVGWyOLcR-ehrhKgfQx5rz4D_HZF_5Fw5ASqcYxEJuAsC7cdZRFtHdyI995PtOB41OjxUKRm8JFg-gOZPg.png"/></div></figure><p>Another big advantage is that we can use the same model <strong>without any changes</strong> for multiple tasks, as the only thing being updated are the embeddings of the prompt tokens. Meaning you can use the same model for a tweet classification task and for a language generation task without any changes to the model itself, given the model is big and sophisticated enough to perform those tasks. But a big limitation is that the model itself doesn’t learn anything new. This is purely a prompt optimization task. This means if the model has never trained on a sentiment classification dataset, prompt tuning might not be of any help. It is <strong>very important</strong> to note that this method optimizes the prompts, not the model. So, if you cannot handcraft a <em>hard </em>prompt that can do the task relatively well, there is no use of trying to optimize for a <em>soft</em> prompt using prompt optimization techniques.</p><h2 id="lora-vs-prompt-tuning">LoRA vs Prompt Tuning</h2><p>Now we have explored various PEFT techniques. Now the question becomes whether to use an additive technique like Adapter and LoRA or you use a Prompt based technique like P-Tuning and Prefix Tuning.</p><p>On comparing LoRA vs P-Tuning and Prefix Tuning, one can say for sure LoRA is the best strategy in terms of getting the most out of the model. But it might not be the most efficient based on your needs. If you want to <strong>train</strong> the model on a much different task than what it has been trained on, LoRA is without a doubt the best strategy for tuning the model efficiently. But if your task is more or less already understood by the model, but the challenge is to properly prompt the model, then you should use Prompt Tuning techniques. Prompt Tuning doesn’t modify many parameters in the model and mainly focuses on the passed prompt instead.</p><p>One important point to note is that LoRA decomposes the weight updation matrix into smaller rank matrices and uses them to update the weights of the model. Even though trainable parameters are low, LoRA updates all the parameters in the targeted parts of the neural network. Whereas in Prompt Tuning techniques, a few trainable parameters are added to the model, this usually helps the model adjust to and understand the task better but does not help the model learn new properties well.</p><h2 id="lora-and-peft-in-comparison-to-full-finetuning">LoRA and PEFT in comparison to full Finetuning</h2><p>PEFT, Parameter Efficient Fine Tuning, is proposed as an alternative to full Finetuning. For most of the tasks, it has already been shown in papers that PEFT techniques like LoRA are comparable to full finetuning, if not better. But, if the new task you want the model to adapt to is completely different from the tasks the model has been trained on, PEFT might not be enough for you. The limited number of trainable parameters can result in major issues in such scenarios.</p><p>If you are trying to build a code generation model using a text-based model like LLaMA or Alpaca, you should probably consider fine-tuning the whole model instead of tuning the model using LoRA. This is because the task is too different from what the model already knows and has been trained on. Another good example of such a task is training a model, which only understands English, to generate text in the Nepali language.</p><h2 id="why-you-should-fine-tune-models-for-your-business-use-case">Why you should Fine-tune models for your business use case</h2><p>Finetuning model is an important step for any business that wants to get the most out of its machine-learning applications. It allows you to customize the model to your specific use case, which can lead to improved accuracy and performance. It saves time, money, and resources by eliminating the need to build a new model from the ground up. Fine-tuning lets you optimize the use of your proprietary data, adjusting the model to better fit your available data, and even incorporating new data if needed. This ensures a more accurate model that better serves your business needs. Here are some more benefits:</p><ul role="list"><li>Customization: Fine-tuning allows you to tailor the model to your specific needs, enhancing accuracy and performance. </li><li>Resource Efficiency: It saves time, money, and resources by eliminating the need to build a new model from scratch. </li><li>Performance Boost: Fine-tuning enhances the performance of the pretrained model using your unique datasets. </li><li>Data Optimization: It lets you make the most of your data, adjusting the model to better fit your available data, and even incorporating new data if needed.</li></ul><p>But as the size of models grows to billions of parameters fine-tuning itself can be a challenge. The  PEFT  techniques we discussed in this blog help to reduce the time and resources needed to fine-tune a model. It helps speed up the training process by making use of the pretrained weights and parameters and allows you to fine-tune the model more efficiently. Also, using PEFT, you can easily transfer models over the internet and even use the same model for multiple purposes. PEFT opens up a whole new world of possibilities for businesses that want to make the most of their machine-learning applications.</p><h2 id="want-to-train-custom-llms-with-peft">Want to Train Custom LLMs with PEFT?</h2><p>If you want to build or train custom LLMs or Chatbots, we can help you fine-tune them to your specific needs. We have done a ton of work on <a href="https://www.mercity.ai/blog-post/custom-gpt-4-chatbot">building custom chatbots</a> and training large language models. Contact us today and let us build a custom LLM that revolutionizes your business.</p></div>
