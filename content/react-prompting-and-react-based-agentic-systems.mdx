---
title: "Comprehensive Guide to ReAct Prompting and ReAct based Agentic Systems"
slug: react-prompting-and-react-based-agentic-systems
publishedAt: "2025-04-19"
createdAt: "2025-04-19"
updatedAt: "2025-04-19"
summary: "In-depth Guide to prompting LLMs via ReACT prompting and how to build production grade agentic systems using ReACT."
authors:
  - name: "Pranav"
category: "Prompt Engineering"
image: "https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/680365971dd5436718724d9d_react_promptinh.png"
---

<h2 id="what-is-react-prompting">What is ReAct prompting?</h2><p>ReAct prompting technique combines the “reasoning” and “acting” capabilities of an LLM to help with tasks like action planning, verbal reasoning, decision-making, and knowledge integration. It does so by forcing the model to <strong>reason</strong> and <strong>observe</strong> before <strong>acting</strong>. This helps the model to analyze the context and situation so far, and then take the actions necessary to move forward. This technique has shown great improvements over past prompting techniques like <a href="https://www.mercity.ai/blog-post/guide-to-chain-of-thought-prompting">CoT (Chain or Thought)</a> and Zero-Shot Prompting.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" style="max-width:1600px" data-rt-type="image" data-rt-align="center" data-rt-max-width="1600px"><div><img src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/68036129ff8442fde23d57db_AD_4nXc4NlGUm5S-w-BXcigzcEJrJlRy6HjsRoTlCDQa63C9egX-47Nl7AhcAaNm58K8UPC6F-KAh3gHKAeqgHtytpG0f4dMVyMbi3PNHAVaPEfYN28iQN4DHs3jwBlIYx9hrf2zv-yLrUDYOYO-WnXs3jpcX2n6.png" width="auto" height="auto" alt="" loading="auto"></div></figure><p>ReAct prompting has also proved to be very effective in tasks like function calling or tool integration, planning ahead, agentic behavior, etc. And it is highly customizable to the specific task at hand. This makes ReAct one of the most used and prominent prompting techniques out there.</p><h2 id="how-to-implement-react-prompting">How to Implement React Prompting</h2><p>Implementing React prompting is actually a very straightforward and easy process. Most of the time a simple prompt with clean instructions suffice. The same goes with customizing the prompt too, minor changes and some examples can easily make the prompt aligned with your specific task.</p><h3 id="zero-shot">Zero-Shot</h3><p>Zero-shot prompting is when the prompt does not contain examples of how to do the task at hand. Zero shot provides <strong>instructions</strong> on how to do a task instead of examples, this is done when the task at hand is very complicated and there is no specific pattern to follow or it is not possible to provide enough examples to explain the task properly to the LLM model.</p><p>Zero Shot prompting works because language models like ChatGPT are “instruction tuned”, meaning they don’t just follow patterns in prompts, but can follow abstract instructions and provide outputs based on that. This removes the need for examples, as the instructions can provide the model with directions on what to do and how to perform the task at hand.</p><p>To implement React with Zero-Shot prompting, you can simply provide a set of instructions on how to follow a React based output scheme in detail, and the LLM will follow. Look at the image below on how we implement the React based prompting simply with instructions and no examples at all.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" style="max-width:1600px" data-rt-type="image" data-rt-align="center" data-rt-max-width="1600px"><div><img src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/68036129440ff51b064d1166_AD_4nXdfHNl4LkHwSeKJNTTqFn-kb4tXqP0p5u4BXBJo_ityS6ejyP5_mr8M5UgLxkReTuRB0zx22tJLs7w8hCxjhKd7EViCqsolLc2WEr6_5c9wkXORoffSV-yZy0K9LHESm4wweNe6-Q.png" width="auto" height="auto" alt="" loading="auto"></div></figure><p>Here is the prompt in the above example, you can use this with any model you like:</p><div data-rt-embed-type='true'><div style="background-color: #2A2A2B;padding: 2.5%;">

<code>
<i>

I want you to solve problems using the ReACT (Reasoning and Acting) approach.For each step, follow the format:
<br>
<br>
Thought: Reason step-by-step about the current situation and what to do next.
<br>
Action: [The specific action to take]
<br>
Observation: [The result of the action]
<br>
<br>
Continue this Thought/Action/Observation cycle until you solve the problem.Then provide your Final Answer.
<br>
<br>
—
<br>
Always output in the given format.

</i>
</code>

</div></div><h3 id="few-shot">Few Shot</h3><p>Few shot prompting on the other hand provides multiple examples to the model for the task at hand. This technique works really well for models that have not been finetuned to follow instructions. Models like GPT-3 are deemed to be “few shot learners” as shown in their <a href="https://arxiv.org/abs/2005.14165">paper</a>. The provided pattern allows the models to understand the problem and learn from the input-output pairs provided in the context. This high-level pattern matching allows models to solve many sophisticated problems without any finetuning.</p><p>Now, few shot prompting is rather rare because of the instruction-tuned models, but we often use few shot along with zero shot. Meaning, that we often provide detailed instructions for the task the LLM is supposed to perform, but along with that we also provide many examples in the prompt to give a demonstration of how to do the task properly. This eliminates the guesswork and covers the edge cases where instructions might not be enough. Few Shot can also be helpful in scenarios where the model can learn more from the examples, and providing a proper set of instructions might be more complicated and introduce more edge cases.</p><p>To implement React with Few-Shot prompting, you just need to provide some additional examples of your use cases and walk the LLM through them if necessary, along with the instructions we provided in the Zero Shot setting. Here’s how we implement ReAct with few shot:</p><figure class="w-richtext-figure-type-image w-richtext-align-center" style="max-width:1480px" data-rt-type="image" data-rt-align="center" data-rt-max-width="1480px"><div><img src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/6803612ac381ab9567f51cd2_AD_4nXejr8-P_OyX-J1YE4R_bN9SZAqwyaFLWZCAD8sqtvI47R1-I7XJHSOaJeQH_zIkWRgfcfLzaSMlnkC1qsF4bQdOH3yuSW-m6pq9Igg8SuToaI7DP1NMJg7DgmBxw_JuQvevq-UEpw.png" width="auto" height="auto" alt="" loading="auto"></div></figure><p>And here’s the prompt used in the above image:</p><div data-rt-embed-type='true'><div style="background-color: #2A2A2B;padding: 2.5%;">

<code>
<i>

I want you to solve problems using the ReACT (Reasoning and Acting) approach.
<br>

For each step, follow the format:
<br>
<br>
Thought: Reason step-by-step about the current situation and what to do next.
<br>

Action: [The specific action to take]
<br>

Observation: [The result of the action]
<br>
<br>
Continue this Thought/Action/Observation cycle until you solve the problem.
<br>
Then provide your Final Answer.
<br>
<br>
Example 1:
<br>
User: What's the population difference between New York City and Los Angeles?
<br>
<br>
Thought: I need to find the populations of both New York City and Los Angeles, then calculate the difference.
<br>
Action: Search for population of New York City
<br>
Observation: New York City has a population of approximately 8.8 million people.
<br>
<br>
Thought: Now I need the population of Los Angeles.
<br>
Action: Search for population of Los Angeles
<br>
Observation: Los Angeles has a population of approximately 3.9 million people.
<br>
<br>
Thought: Now I can calculate the difference between the two populations.
<br>
Action: Calculate 8.8 million - 3.9 million
<br>
Observation: The difference is 4.9 million.
<br>
<br>
Final Answer: The population difference between New York City and Los Angeles is approximately 4.9 million people, with New York City having the larger population.
<br>
<br>
Example 2:
<br>
User: What's the capital of France and what's its population?
<br>
<br>
Thought: I need to find the capital of France and then its population.
<br>
Action: Identify the capital of France
<br>
Observation: The capital of France is Paris.
<br>
<br>
Thought: Now I need to find the population of Paris.
<br>
Action: Search for population of Paris
<br>
Observation: Paris has a population of approximately 2.1 million people.
<br>
<br>
Final Answer: The capital of France is Paris, and it has a population of approximately 2.1 million people.
<br>
<br>
—
<br>
Always output in this format

</i>
</code>

</div></div><h3 id="parameters-and-points-to-keep-in-mind">Parameters and Points to keep in mind</h3><p>When working with React, there are many variations and parameters to keep in mind. The classical LLM parameters like temperature and top-p are not very relevant here. As in the paper authors have not mentioned temperature or any specific LLM configuration anywhere, we can assume that they worked mostly with temperature set to 0.&nbsp;</p><p>The authors do mention that they worked with Chain of Thought prompting with Self-Consistency where they generated 21 chains of thoughts using the LLM with temperature set to 0.7 and used the majority as the answer. They mentioned that this technique boosted performance over classical Chain of Thought prompting, but was still less than ReAct’s accuracy. However, Chain of Thought and Chain of Thought with Self Consistency performed much better than React on the <a href="https://hotpotqa.github.io/">HotpotQA benchmark</a>.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" style="max-width:1600px" data-rt-type="image" data-rt-align="center" data-rt-max-width="1600px"><div><img src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/6803612a17c442704a19bc45_AD_4nXdjkolIreCe1WWfSA660cbM1flEjLS8HovGbG9Ghrpr8kQZWs_pq7xeyIMhLi4ot08teN5BDeoUwTkfVQutNmH4JBTmAaNSZXQgdiDnK5kQKme9jInNM7rDah0GO9XnKCsCeljH7YsdKxvIIiRdGfhFcSVC.png" width="auto" height="auto" alt="" loading="auto"></div></figure><p>Keeping this in mind, React performs much better with temperature 0 on most tasks, except those similar to HotpotQA, which is mainly fact-based question-answering. But, React combined with CoT-SC gives SOTA results, so it’s a very difficult decision on what to use exactly. It is suggested to test out different variations and then pick one that works for your task.</p><p>Another variation to test is something the authors call “Act Only” prompting. This is where you take away the REasoning part of the prompt and the model, leaving only Action and Observation. Similar approaches have been used before to make LLMs interact with tools and external information but ReAct improves upon them almost all the time. Still, Act-only prompting is worth testing if your task is basic enough and doesn’t require too much reasoning, this can help you save on token costs and reduce latency a little.</p><h2 id="function-calling-with-react">Function Calling With React</h2><p>Because React prompting has the idea of “act” built into it, it is very easy to build function calling or tool calling flows with it. You simply have to create various “actions” for your model and give it permission to call them, and it will do so in the action section of its outputs.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" style="max-width:1600px" data-rt-type="image" data-rt-align="center" data-rt-max-width="1600px"><div><img src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/6803612ac381ab9567f51cf7_AD_4nXdiYF8dedxvvdGGABN8SzbSOkyd06SbYgxGed466OkeOWbZ-gqMzn1iDUEY8-oGekF7mkTQ3UADhccsjhbkE24EaE5r5qVYq2YD44DImwsdaAwC3QJMdXjoiCvlT8lijxExjRmd1g.png" width="auto" height="auto" alt="" loading="auto"></div></figure><p>Then you would need to register triggers based on certain actions of the model, to do that you can use a simple <em>.contains</em> or a regex to detect presence of actions. Once detected, pause the flow of the React model, and execute the action the model wanted, and then provide back the response. You can easily provide back the response by pasting it in the Action section after the function call, like this:&nbsp;</p><p><strong>Act: GetCurrentWeather() -&gt; {“temp”: “72F”, “wind”: “8mph”, “cond.”: “Partly Cloudy”}</strong></p><p>You can simply append the output of the function after an <strong>-&gt;</strong> and resume execution from there. The model will then output an “Observation”, unless some other step is specified.</p><p>This is a very basic and straightforward flow, although massively extendable and you can change the set of actions and how the model reasons as the model moves ahead. Maybe the model has already deleted a file once, you can just remove the <strong>DELETE</strong> action from the model’s action set, or can add new actions to the model hence improving the performance of the model as the flow progresses.</p><h3 id="function-calling-with-arguments">Function calling with Arguments</h3><p>Another very important aspect of calling functions using LLMs is calling them with arguments. Not all functions are stateless. Some require specific information to act upon, or simply to work with to provide an output to the user. A classic example is if the user asks for weather at a specific place like Seattle or New York, then the function needs to also accept a location as an argument or a parameter to execute properly.</p><p>This is also very simple to execute with React as it is mostly about changing how the functions are defined and how they are parsed by the parser afterwards. You can simply tell the model to output actions in a specific format when calling the function with arguments. For example:</p><figure class="w-richtext-figure-type-image w-richtext-align-center" style="max-width:1600px" data-rt-type="image" data-rt-align="center" data-rt-max-width="1600px"><div><img src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/6803612a1dd54367186f4596_AD_4nXeGAUYEEkCEl3JsZbHeQv2MNFxPvoXjUuCrLY3kc26LZqaRA4O-niM69nx1_YQ6O6xC_S9VvUzDJdX8S1litpzJYfyEbtvWpR8eHmf9FugQyrynDya-igc9VJKan45DVcIwElS7qg.png" width="auto" height="auto" alt="" loading="auto"></div></figure><p>Once the format is established, you can update the parser to parse the function calls accordingly and pass on to the execution pipeline.</p><p>One very important point to note here is that as you introduce more and more functions and tools for the model, it starts making more mistakes and hallucinations might become more common. This is very rare and happens when you have a lot of functions with lots of parameters, but still, can and does happen specifically in enterprise applications, it is important to maintain these issues properly. One common way is to use forced grammar to make sure the model doesn’t make syntactical errors. The <a href="https://github.com/dottxt-ai/outlines">outlines</a> library implements this pretty seamlessly, HuggingFace has a good guide for <a href="https://huggingface.co/docs/text-generation-inference/en/basic_tutorials/using_guidance">TGI Structured Outputs</a>, and VLLM also supports <a href="https://docs.vllm.ai/en/latest/features/structured_outputs.html">multiple libraries</a> for the same task.</p><h3 id="integrate-with-external-knowledge-bases">Integrate with External Knowledge Bases</h3><p>Because of the function calling capabilities, it makes it much easier to integrate with external sources using React prompting. Simply need to add the action set to call APIs, perform RAG operations, etc and the model will take care of it.</p><p>Here’s our guide on how you can integrate tools and functions with LLMs.</p><p><a href="https://www.mercity.ai/blog-post/guide-to-integrating-tools-and-apis-with-language-models">Comprehensive Guide to Integrating Tools and APIs with Language Models</a></p><p>We do not use ReACT in this guide, but React can simply be extended to use the same principles as we outlined in the blog.</p><h2 id="react-vs-chain-of-thought-prompting">ReAct vs Chain of Thought Prompting</h2><p>Now both ReAct and <a href="https://www.mercity.ai/blog-post/guide-to-chain-of-thought-prompting">Chain of Thought (COT)</a> are very similar prompting styles given that they force the model to <strong>reason before answering</strong>, and that’s where most of the gains in performance comes from.</p><p>Although, Chain of thought is much better when it comes to extensive reasoning, and multi step thoughts are required. For example when solving a math problem, the problem needs to be simplified and then solved. COT is much better at linear reasoning and then reaching a result.</p><p>Example:</p><p><em>Problem: What is 17 × 24?</em></p><p><em>CoT: I'll multiply step by step.</em></p><p><em>&nbsp;	17 × 20 = 340</em></p><p><em>&nbsp;	17 × 4 = 68</em></p><p><em>&nbsp;	340 + 68 = 408</em></p><p><em>Answer: 408</em></p><p>React is more dynamic than Chain of thought. Along with reasoning it lets you introduce a cycle of observations and actions, which let you use react for dynamic conditions and rather for “actions” than just for reasoning and solving problems. This makes it a little worse at solving linear problems, but makes it much better and easier to work with when tools, dynamic conditions and other challenges are involved.</p><p><em>Task: Find population data for New York and calculate its growth rate</em></p><p><em>Thought: I need population data for New York for different years.</em></p><p><em>Action: Search for "New York population data 2010 and 2020"</em></p><p><em>Observation: 2010 population: 19,378,102; 2020 population: 20,201,249</em></p><p><em>Thought: Now I can calculate the growth rate.</em></p><p><em>Action: Calculate (20,201,249 - 19,378,102) / 19,378,102 × 100</em></p><p><em>Observation: 4.25% growth</em></p><p><em>Thought: The population growth rate of New York from 2010 to 2020 was 4.25%.</em></p><h2 id="advantages-of-react-prompting-over-normal-prompting">Advantages of ReAct Prompting over normal prompting?</h2><p>There are a few reasons why you would pick the ReAct prompting structure over normal prompting structures. It usually provides you with more control, more structured outputs, and lets you direct the model exactly how to proceed in most scenarios. Let’s discuss these points in more detail.</p><h3 id="gives-a-window-into-the-llms-thinking-process">Gives a window into the LLM’s thinking process</h3><p>Using ReAct gives you a better understanding of how the LLM is working to solve the problem as it deconstructs the problem and solution steps into a very well-structured format. This means you as the developer or prompter, can sit down and nitpick exactly what you don’t like in the model’s thinking process.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" style="max-width:1600px" data-rt-type="image" data-rt-align="center" data-rt-max-width="1600px"><div><img src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/6803612968e3355dea8605df_AD_4nXej5dBBVCePyAJMMkCKzXgOQSxlpFc0GG-kZziohHdM0qbO7jJi65pktKd6yYbuB9LVVE5u1F6hjs2kf7Vycx6LkLYPXuoxG82WUuLkzxBMK5AaAOf6r5oUB9HVxTgQlpeaoRqG.png" width="auto" height="auto" alt="" loading="auto"></div></figure><p>You can tell the model to reason in a specific way, and define exactly how to act and what to observe in certain scenarios. Along with this control, you can group or cluster LLM’s responses and figure out where the model makes the most mistakes, maybe most of the mistakes are happening when a certain ACTION is executed. This gives you a very deep insight into how the model is behaving, and how you can go about steering it to provide better responses.</p><h3 id="gives-stricter-control-over-the-llms-outputs">Gives stricter control over the LLM’s outputs</h3><p>Better observability leads to better control. Once you see all the thoughts of the LLM, you know exactly where to interject. For example, if the model is working on mathematical problems, you can prompt the model to <em>“Spend some time breaking the equation down into the most basic parts and then call the Calculator too”</em>, or when the model is in self-correction mode, you can tell it to analyze all of its past reasoning steps and actions in massive detail and ask it to find out errors.</p><p>This is just from an prompting perspective, you can do much more complex things like asking the model to “Reason Twice” – one time from two different perspectives. And then combine that and in the third reasoning step and then act. Such things are much more complex but are needed to solve some more tricker and complex problems. For example, if you are building a bot which talks about philosophy with the users, you really need it to think and evaluate its arguments from multiple perspectives before providing an answer. Using React prompting in such scenarios is a very straightforward way to build your solution.</p><h3 id="react-can-help-design-programmatic-flows-and-multistep-solutions">ReAct can help design Programmatic Flows and Multistep Solutions</h3><p>This is an application of ReACT prompting that has not been explored much, but it is possible and leads to amazing results. Because you can control React’s outputs and reasoning traces very strictly, you can build flows on top of them. Often multiple steps are needed to solve a problem, rather than just one single step. For example, generating SEO articles, if you do it in one step the results can be good, but much better flow is to generate the article and THEN optimize it with a SEO optimization specific prompt.</p><p>Here’s a visual example of how an agentic or multistep flow would work with ReACT</p><figure class="w-richtext-figure-type-image w-richtext-align-center" style="max-width:1600px" data-rt-type="image" data-rt-align="center" data-rt-max-width="1600px"><div><img src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/6803612a440ff51b064d118a_AD_4nXdn12coPoznKiYlD1V6JkPGfFrHLx5IHeu6NaQwwhTlKtcIG9QNo_IZiQ5hDbPsV3-NLxQRkYSFIY8-I_bo06PFnUtKL6eTDcYg-LLcE2mLNWqK1Q6DIpLTSulUye6GRoys9QmBdg.png" width="auto" height="auto" alt="" loading="auto"></div></figure><p>You can write sophisticated prompts to do all this in one-shot, yes, but then it makes it much harder to control and change parts of the model and the output. Using ReACT and a multistep flow gives you the freedom to tune every single step individually.</p><p>Straightforward way to do this is to hook up <strong>triggers</strong> to certain actions or observations of the model, example, if the model’s action is to edit a specific part of the article, you use another prompt and model set that is more tuned to editing articles than writing it, and if the model observes a factual inconsistency, you can use another model to fix it, than fixing it in the same react flow. This method lets you branch off from the core flow of the model output and do multiple tasks parallelly. In such a flow the ReACT flow sits as the main stream of the model’s actions, and outputs triggers, and various other actions are done based on the triggers from the main stream.</p><h2 id="react-prompting-with-langchain">React Prompting with Langchain</h2><p>Now <a href="https://www.langchain.com/">Langchain</a> is one of the most popular methods to build AI agents and simple workflows, here’s a small snippet on how to build a basic react agent using langchain. You simply need to import “create_react_agent” and configure it with your tools and query and you are good to go!</p><p>One small thing is that Langchain is pretty good, but sometimes it abstracts away too much, don’t use it if you want more customization in your flows!</p><div data-rt-embed-type='true'><pre>
<code class="language-py">
from langgraph.prebuilt import create_react_agent

langgraph_agent_executor = create_react_agent(model, tools)

messages = langgraph_agent_executor.invoke({"messages": [("human", query)]})
{
	"input": query,
	"output": messages["messages"][-1].content,
}

</code>
</pre></div><h2 id="some-tips-when-working-with-react-prompting">Some tips when working with ReACT Prompting</h2><p>We at Mercity have been working with LLMs for years now, here are some points that we have learned from a lot of experience in ReACT prompting that you can use too.</p><h3 id="react-is-very-extensible">ReACT is very Extensible</h3><p>We mentioned in the starting that the React works by breaking the outputs down into <strong>reasoning</strong>, <strong>action </strong>and then<strong> observation</strong>. This is actually not a strict rule, just a general pattern that is suggested to be followed. You can completely remove the <strong>action</strong> step if you do not need it. And you can add multiple reasoning steps if you want, or maybe multiple action steps.</p><p>This comes in handy when you are working with more tricker and sophisticated applications, maybe it requires you think from multiple perspectives before answering an question, that;s where you can have multiple reasonings, maybe you want to have only one very long and extensive reasoning and then multiple observations and actions based off of that single very long reasoning step – that is possible too. And it will save you a lot of time, as reasoning is where most of the time is spent by the model.</p><p>This extensibility allows you to reshape the technique completely for your own use case, without hampering, and often increasing performance over baseline react prompting method.</p><h3 id="react-prompting-format-does-not-matter">ReACT prompting format does not matter</h3><p>Along with extensibility, the format is very flexible too. You can output in JSON if you want, XML or even YAML, none of which affect performance in any major way.</p><p>We like to use XML internally, simply because it is easier to manage and work with when things get complex and there are many nested clauses. But, most of the people like to use JSON as it is the easiest way to get the model working as soon as possible and parsing it is very easy too.</p><p>The idea is, that you are not bound to any specific format, as long as your are following the general ReACT output pattern, you should be able to get similar performance!</p><h3 id="utilize-direct-function-calling">Utilize direct Function Calling</h3><p>Many providers like OpenAI and Anthropic now provide their own function calling features and have internal systems set up to make sure you get high accuracy when dealing with functions. Here’s <a href="https://platform.openai.com/docs/guides/function-calling?api-mode=responses">openAI’s guide on function calling</a>.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" style="max-width:1190px" data-rt-type="image" data-rt-align="center" data-rt-max-width="1190px"><div><img src="https://cdn.prod.website-files.com/640f56f76d313bbe39631bfd/6803612a17c442704a19bc33_AD_4nXc5K3T8RGsGHJE-rWtXfEogx8vbCNffBDusGBoBbfbIjw4ZdSUtScvhpOYgxh_kPaWEGiRPML46Ll0npPi0O8vN00gZmCVNK-BsyHIlgjDdtAQX_XKKHM73cvWyktz8vbrAxwgt.png" width="auto" height="auto" alt="" loading="auto"></div></figure><p>React is indeed a good method to induce function calling from LLMs, but when working with providers it's usually better to use the features they provide for it. They set up a lot of things underneath, make sure you use all that.&nbsp;</p><p>Another very important thing to note is that even Open Source models like LLaMA and Mistral now have special tokens to manage function list and function calling, here is a <a href="https://github.com/meta-llama/llama-models/blob/main/models/llama3_3/prompt_format.md">guide on how llama does it.</a></p><h2 id="want-help-with-your-react-prompting-workflows">Want help with your React Prompting workflows?</h2><p>We at mercity have been working with LLMs for years now and have written all sorts of prompts, and especially many variants of React.</p><p><a href="https://www.mercity.ai/contacts">Contact us</a>, if you need any help with your prompting workflows!</p>
